[
["index.html", "Microbiome in R Exploring microbiome analysis using R Forewords", " Microbiome in R Exploring microbiome analysis using R Nabiilah Ardini Fauziyyah March 19, 2020 Forewords All praises be to Allah, The Beneficent and The Ever-Providing, who have given me the time, well-being, and intention to develop a companion book on Microbiome Study in R. This work is far from completed and will not be possible without the help many many friends and parties. With the hope of helping many people who ought to learn Microbiome Analysis as soon as possible, this work was published and will be continually updated. Microbiome Analysis is the analysis of a community of microorganisms (such as bacteria, fungi, and viruses) that inhabit a particular environment. The understanding of microbial community profiles from a specific environment, its dynamics, and clearer understanding of microbial role in the environment will provide us a huge lift on scientific discoveries and the initiation of further research for the improvement of human lives. With the development bioinformatics tools and package in R, microbiome analysis is getting more easier and accessible than ever. This book is made with the intention to bring microbiome analysis using R closer to you. You may be a data scientist with curiousity about microbiome or may be a biologist trying to learn new technology i.e. R to tackle your research project. This book hopefully shed a light on how microbiome analysis is performed, providing a comprehensive review and tutorial on the process of transforming microbiome raw data into valuable insight. Happy reading! "],
["microbiome-and-beyond.html", "Chapter 1 Microbiome and Beyond", " Chapter 1 Microbiome and Beyond Our earth has always been a home for billions of magnificent species that captivated the eye, including us. Every living thing occupies their respective habitat and evolves with it. But there are more than what is seen with the eyes! An abundant number of tiny organisms–even unseen to the naked eyes–has also been living with us all along. These tiny organisms are called microbes. Microbes are single-cell organisms that are approximately 1-5 micrometer in size, consisting of various species of bacteria and fungi (some said that viruses are also included). Although microbes are the smallest forms of life, they live in almost every place on earth, even inside our bodies. They have adapted to thrive in the normal and the most extreme condition on earth. Microbes live as a community and exchange various chemicals and nutrients that support their own growth and affect the ecosystem around them. For example, the oxygen we breathe in is the result of the past microbial activity of cyanobacteria from around 2.4 billion years ago, which risen the earth’s oxygen level and introduced what called as the great oxygenation event. Recent research also showed that a particular community of microbes lives inside our gut and can perform symbiotic relationships with us. It can secrete chemicals that boost our digestive system, prevent attack by harmful bacteria or viruses, program our immune system, and even direct our appetite, in exchange for a living space. In contrast, a particularly bad community of microbes can also live inside our gut and linked with a higher risk of several disorders including allergies, obesity, diabetes and many types of cancer (Sally Temraz 2019). This specific microbial community that lives in a particular environment is what we called as microbiome. The microbiome evolves as the environment evolves. This is why the microbiome has been linked with the ‘unseen’ force that supports and maintains the earth as well as the biological profile that describes that specific environment. Microbiome is often used to describe a specific condition of an environment. From our previous example, the gut microbiome profile can act as a biomarker for a healthy gut or a specific type of disease. The understanding of microbiome is also very powerful for environmental study. This study answers questions such as, What kind of community of microbes lives in a polluted river? What it consist of? In what way does each microbes from that community affect the environment they live in? Which microbes can act as a biomarker for polluted or unpolluted river? What actions that may recover or worsen the state of polluted river based on its microbial community (by utilizing the knowledge on microbial activity that may affect the environment), and so much more. The study that focuses on the discovery and the understanding of the microbiome is called Microbiome Analysis. It aims to discover microbial community profiles from a specific environment, understand the community dynamics in various conditions, and provide a clearer understanding of their role in the environment. In practice, this study often results in new findings for biomarkers that can be used to detect specific diseases or conditions in health and environmental studies. Further research may also open the door for the development of personalized diet or treatments! Microbiome analysis is one of the many topic that fall under the collaboration between Data Science and Biology. It envolves the processing of genetic data into pattern and visualization that we can gain insight from it. Although microbiome analysis is mainly focused on discovering patterns, it acts as a solid example of how explanatory data analysis can play a huge role in scientific discoveries and initiate further research for the improvement of human lives. In the next section, we will uncover what are the steps that build up a microbiome analysis and what is the idea behind them. "],
["microbiome-analysis-workflow.html", "Chapter 2 Microbiome Analysis Workflow 2.1 The Lab Work 2.2 Bioinformatic Analysis", " Chapter 2 Microbiome Analysis Workflow The workflow of microbiome analysis has evolved through out the years. The development of technology and Bioinformatics has made a massive increment on the generation of genomic data that is used for microbiome analysis. Therefore, the use of programming tools such as R and its packages is becoming more widely used. If I may put it into 2 major steps, microbiome analysis consist of “Lab Work” and “Bioinformatic Analysis”. The lab work of a microbiome analysis is quite plenty and mostly technical, which I will not explain it detail in here. Meanwhile, the bioinformatic analysis will be explained in this book with some tutorial. We will be using R languages and its packages as bioinformatics tools. 2.1 The Lab Work Every lab work of a microbiome analysis begins by taking a sample of microbial community from either soil, water, swab of a surface, saliva, or any other habitat. The microbes present in that sample will then be filtered and extracted for their DNA. Each microbial DNA will be sequenced to retrieve its genetic code, specifically in the region of a “fingerprint gene” called the 16S ribosomal RNA (16S rRNA). The process briefly explained in the illustration below (Fig 2.1). For those of you who are not familiar with cell and molecular biology, these are a brief explanation. DNA is a molecule that harbors genes or sequences of genetic code of a living things. This DNA can be used as a taxonomic marker that differentiate each microbial species from one another. A specific region of DNA called the 16S rRNA gene is usually used for comparation, for this gene exist in all of microbes but has slightly different sequence for each microbes. The difference between each sequence will be calculated to determine how distant or related a microbial species with one another. 2.2 Bioinformatic Analysis After we have the sequencing result, the bioinformatic analysis can be performed. The steps consist of assigning taxonomy or giving identity to the unknown DNA samples and analysis of the their community structure and dynamics. We can analyze the community structure and dynamics by calculating the diversity and abundance of each microbes present in the samples. We will able to know which microbes dominates over the other, what microbial activities it can do that may affect the environment being studied, etc. This microbial community profile will help us understand the phenomenon happen in a specific environment. We may even discover potential biomarker for industrial application. From the technical side, the steps of bioinformatic analysis starts from the dirty data cleaning, performing some data pre-processing, followed by applying some algorithms, and finalized by some data visualization and extracting valuable insight. Below is the summary of Bioconductor Workflow for Microbiome Data Analysis adapted from Ben J. Callahan (2016) and several documentation from updated packages commonly used for microbiome analysis. Bioconductor itself is a repositories of open source software for Bioinformatics, based on packages written primarily in the R programming language. Amplicon Bioinformatics: from raw reads to tables Microbiome analysis: community structure, abundance, and diversity Microbiome analysis: community profile visualization using PCA Microbiome analysis: supervised learning Microbiome analysis: graph analysis using network visualization We will discuss deeper for each steps of microbiome analysis and the packages related to it in the following section. A tutorial installing Bioconductor packages also provided in the next section, for it is slightly different than what we usually do when installing packages from CRAN. "],
["bioconductor-installation.html", "Chapter 3 Bioconductor Installation", " Chapter 3 Bioconductor Installation Numerous packages for bioinformatics analysis stored in Bioconductor repository. The current release of Bioconductor is version 3.10 and works with R version 3.6.0. Users of older R and Bioconductor must update their installation to take advantage of new features and to access packages that have been added to Bioconductor since the last release (Bioconductor 2020). Install the latest version of Bioconductor by entering the commands below: if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) # progress &amp; error suppressed install.packages(&quot;BiocManager&quot;) BiocManager::install(version = &quot;3.10&quot;) In additition, if you see the following messege during installation: That’s its way to notice you that there are some packages (usually from CRAN repository) that is out-of-date. You can type a in the console to install the latest updates or any other option available (some or none). You may also install the latest updates manually from the ‘Packages’ panel. To install specific packages from Bioconductor, use the following commands: # packages for microbiome analysis BiocManager::install(c(&quot;BiocStyle&quot;, &quot;dada2&quot;, &quot;phyloseq&quot;)) Now, many have questioned why there is a need to use BiocManager::install() to install packages from Bioconductor. This is because Bioconductor has a repository and release schedule that differs from R. A consequence of the mismatch between R and Bioconductor release schedules is that the Bioconductor version identified by install.packages() is sometimes not the most recent ‘release’ available. The BiocManager package serves as the primary way to ensure that the appropriate Bioconductor installation is used with respect to the version of R in use regardless of the R and Bioconductor release cycles (Bioconductor 2020). For further documentation of the installation of Bioconductor, click here. "],
["amplicon-bioinformatics.html", "Chapter 4 Amplicon Bioinformatics 4.1 Libraries 4.2 Dataset 4.3 Trimming &amp; Filtering 4.4 Infer Sequence Variants 4.5 Merge Forward &amp; Reverse Reads 4.6 Construct Sequence Table &amp; Remove Chimeras 4.7 Assign Taxonomy 4.8 Create Phyloseq Object", " Chapter 4 Amplicon Bioinformatics This section demonstrates the first step of performing microbiome analysis in R. Amplicon bioinformatics include construction of the raw reads from sequencing result into the table we ought to analyze. Below is an illustration of what we are going to do in amplicon bioinformatics (Fig 4.1). 4.1 Libraries First, we should load the necessary packages. You might also want to install some packages if you haven’t installed them to your machine. # CRAN libraries library(knitr) # for reporting library(ggplot2) # for graph visualization library(gridExtra) # additional mapping for ggplot2 library(tidyverse) # for general data cleaning/manipulation # Bioconductor libraries library(dada2) library(phyloseq) library(Biostrings) We will be using a lot of functions from DADA2 package for amplicon analysis and therefore I will be following DADA2 Pipeline Tutorial (1.12) Callahan (n.d.). Through out the tutorial, I will try to explain each step in hopefully a more friendly manner for people who are new to this analysis. 4.2 Dataset The dataset for microbiome analysis is usually a set of raw reads of DNA sequences a.k.a. amplicons stored in a digital format as a result of DNA sequencing method performed in labs. The DNA of a microbial species needs to be sequenced first to retrieve its information and store it in a digitalized form. There are various tools for DNA sequencing with the Next Generation Sequencing (NGS) technology being commonly used today. It allows rapid sequencing for a massive load of DNA sequences simultaneously. You are free to use your own amplicons dataset while following the tutorial provided in this book. But please do notice that the data should met certain criteria as follows: Samples have been demultiplexed, i.e. each samples have their own DNA sequence (.fastq file). Non-biological sequences have been removed, i.e. the samples are free of primers and other artificial sequences from lab work processes. If paired-end sequencing data, the forward and reverse .fastq files contain reads in matched order. Meanwhile, if you don’t have one, you can use the mothur MiSeq SOP data provided free in here. The data is also used on the original tutorial. The data consisted of amplicons from the V4 region of the 16S rRNA gene sequenced through Illumina Miseq NGS technology. The V4 region stands for the more specific region of the 16S rRNA gene. The data contains DNA from microbial communities collected from gut samples of a mouse during post weaning growth (after milk diet). The original experiment were done with the aim to understand the effect of normal gut microbiome to the mouse health. The full data is extremely large to process for this introductionary phase (3.9 GB) and therefore we will be using only parts of the data. With the available data we have, let’s try to understand the effect of the first 10 days of post weaning (eating) period to the stability of gut microbiome in the 140-150 day of post weaning period. These are the steps for reading the data: The data can be downloaded in the link provided above. The data will be in .zip format. You will need to extract it to obtain the amplicons in .fastq format and some additional files. There will be 45 files consisted of: 19 forward reads of community DNA samples 19 reverse reads of community DNA samples 1 forward reads of control (mock) samples 1 reverse reads of control (mock) samples 1 HMP_mock.v35 fasta (annotated (named) DNA from mock samples) 5 additional information files: mouse.dwp.metadata mouse.time.design stability.batch stability files For those of you who are interested in understanding more about the sample it is a good idea to read the original research publication and perhaps also articles about designing an experiment including its control. The DNA samples or amplicons are stored with a standard naming system: F3D0 stands for the mouse id F3 and the day of sampling D0 the R1 and R2 stands for forward and reverse reads respectively. Forward and reverse reads came from the sequencing method which sequenced DNA in two direction just as illustrated in Fig 4.1. Here is a great video about DNA sequencing for more detailed process. Before further analysis, forward and reverse reads of DNA need to be “cleaned” first for its low quality reads and then joined to obtain the full DNA. The data cleaning process is called Trimming and Filtering which we will discuss in the next section. Below, the amplicons will be tagged for data cleaning process. The amplicons may still be in its compressed format (.fastq.gz) but the one we have are not. For those of you who have the compressed format, luckily most bioinformatics tools have the ability to process even the compressed files. This is quite a convenience as most microbiome analysis deals with large-sized data and compressed files are, well, more “compressed”. The code below will try to list all the amplicons stored in our working directory and separate them between the reverse or forward reads for the data cleaning process. # list amplicons into forward/reverse reads amplicons_F &lt;- sort(list.files(path = &quot;data/MiSeq_SOP&quot;, # location of your amplicons pattern = &quot;R1&quot;, # forward reads full.names = TRUE)) amplicons_R &lt;- sort(list.files(path = &quot;data/MiSeq_SOP&quot;, pattern = &quot;R2&quot;, # reverse reads full.names = TRUE)) # check the first 6 data head(amplicons_F) ## [1] &quot;data/MiSeq_SOP/F3D0_S188_L001_R1_001.fastq&quot; ## [2] &quot;data/MiSeq_SOP/F3D1_S189_L001_R1_001.fastq&quot; ## [3] &quot;data/MiSeq_SOP/F3D141_S207_L001_R1_001.fastq&quot; ## [4] &quot;data/MiSeq_SOP/F3D142_S208_L001_R1_001.fastq&quot; ## [5] &quot;data/MiSeq_SOP/F3D143_S209_L001_R1_001.fastq&quot; ## [6] &quot;data/MiSeq_SOP/F3D144_S210_L001_R1_001.fastq&quot; head(amplicons_R) ## [1] &quot;data/MiSeq_SOP/F3D0_S188_L001_R2_001.fastq&quot; ## [2] &quot;data/MiSeq_SOP/F3D1_S189_L001_R2_001.fastq&quot; ## [3] &quot;data/MiSeq_SOP/F3D141_S207_L001_R2_001.fastq&quot; ## [4] &quot;data/MiSeq_SOP/F3D142_S208_L001_R2_001.fastq&quot; ## [5] &quot;data/MiSeq_SOP/F3D143_S209_L001_R2_001.fastq&quot; ## [6] &quot;data/MiSeq_SOP/F3D144_S210_L001_R2_001.fastq&quot; # extract sample names sample_names &lt;- basename(amplicons_F) %&gt;% # get file names word(start = 1L, sep = &quot;_&quot;) # get the first word as the sample names head(sample_names) ## [1] &quot;F3D0&quot; &quot;F3D1&quot; &quot;F3D141&quot; &quot;F3D142&quot; &quot;F3D143&quot; &quot;F3D144&quot; 4.3 Trimming &amp; Filtering After we have separate the sequences into reverse/forward, we need to perform data cleaning by trimming &amp; filtering. Raw reads are often have regions with low-quality reads. Most Illumina sequencing data shows a trend of decreasing average quality towards the end of sequencing reads (Ben J. Callahan 2016). To know which regions have low quality reads, we can plot it using plotQualityProfile() from DADA2 package. This function plots a visual summary of the distribution of quality scores for each sequence position. For more clarity, one amplicon files consist of numerous DNA sequences from each microbial present in one community sample. Each sequences calculated for its quality score in each sequence position (first to last). The plot will generate the summary of quality score from all the DNA sequences in one sample. Let’s take the first 3 observation and plot its reverse and forward reads for its quality profile. From there we can determine which position with low quality reads and trim them later. # plotting 1st observation f_plot &lt;- plotQualityProfile(amplicons_F[1:3]) + labs(x = &quot;Sequence Position&quot;) r_plot &lt;- plotQualityProfile(amplicons_R[1:3]) + labs(x = &quot;Sequence Position&quot;) grid.arrange(f_plot,r_plot,ncol = 1) The distribution of quality scores at each sequence position is shown as a grey-scale heatmap. The darker color represent higher frequency of each quality score at each sequence position. Notice that I’ve intentionally changed the x label for easier interpretation. It also shown the quality score summary: green line: mean quality score orange line-solid: median quality score orange line-dashed: 25th and 75th quantiles Reads: number of reads (DNA sequences present in a sample) red line: scaled proportion of reads that extend to at least that position (this is more useful for other sequencing technologies, as Illumina reads are typically all the same length, hence resulting a flat red line). The forward reads are in good quality, but it is still better to trim a few of the first/last position of a sequence to avoid errors that can arise there. In this example, we will trim the first 10 positions because based on empirical observations across many Illumina datasets, the first or last 10 positions are particularly likely to contain pathological errors (Ben J. Callahan 2016). Meanwhile, the reverse reads are more worse in quality, especially at the end. From the plot result, we will trim the last 160 positions from the reverse reads. After determining the trimming position for each forward &amp; reverse reads, we will combine it with the standard filtering parameters maxEE = 2 (the maximum number of expected errors allowed in a read is 2)(Ben J. Callahan 2016). Trimming and filtering is performed on paired reads jointly, i.e. both reads must pass the filter for the pair to pass. In the code below, we first create a file path for our filtered reads in the working directory and then perform the trimming and filtering. # creating directory for filtered reads if(!file_test(&quot;-d&quot;, &quot;data/filtered&quot;)) #&quot;if there is no directory `data/filtered`, dir.create(&quot;data/filtered&quot;) # &quot;create one&quot; # creating file path # &quot;data/filtered/sample_names_*_filtered.fastq.gz&quot; filtered_F &lt;- file.path(&quot;data&quot;, &quot;filtered&quot;, paste0(sample_names,&quot;_F_filtered.fastq.gz&quot;)) filtered_R &lt;- file.path(&quot;data&quot;, &quot;filtered&quot;, paste0(sample_names,&quot;_R_filtered.fastq.gz&quot;)) # check the file path head(filtered_F, 3) ## [1] &quot;data/filtered/F3D0_F_filtered.fastq.gz&quot; ## [2] &quot;data/filtered/F3D1_F_filtered.fastq.gz&quot; ## [3] &quot;data/filtered/F3D141_F_filtered.fastq.gz&quot; # trimming &amp; filtering tnf_summary &lt;- filterAndTrim(amplicons_F, filtered_F, # input and output amplicons_R, filtered_R, # trimming trimLeft=10, # trim the first n observation from each reads truncLen=c(240,160), # truncate reads after this position; c(Forward/Reverse) # filtering standard maxN=0, maxEE=c(2,2), # max expected error (maxEE) = 2 truncQ=2, rm.phix=TRUE, # additional setting compress=TRUE, # whether outputs should be compressed multithread=FALSE) # default for Windows, Mac can use `multithread=TRUE` tnf_summary ## reads.in reads.out ## F3D0_S188_L001_R1_001.fastq 7793 7139 ## F3D1_S189_L001_R1_001.fastq 5869 5314 ## F3D141_S207_L001_R1_001.fastq 5958 5478 ## F3D142_S208_L001_R1_001.fastq 3183 2926 ## F3D143_S209_L001_R1_001.fastq 3178 2955 ## F3D144_S210_L001_R1_001.fastq 4827 4323 ## F3D145_S211_L001_R1_001.fastq 7377 6762 ## F3D146_S212_L001_R1_001.fastq 5021 4580 ## F3D147_S213_L001_R1_001.fastq 17070 15695 ## F3D148_S214_L001_R1_001.fastq 12405 11448 ## F3D149_S215_L001_R1_001.fastq 13083 12064 ## F3D150_S216_L001_R1_001.fastq 5509 5054 ## F3D2_S190_L001_R1_001.fastq 19620 18130 ## F3D3_S191_L001_R1_001.fastq 6758 6275 ## F3D5_S193_L001_R1_001.fastq 4448 4068 ## F3D6_S194_L001_R1_001.fastq 7989 7394 ## F3D7_S195_L001_R1_001.fastq 5129 4772 ## F3D8_S196_L001_R1_001.fastq 5294 4890 ## F3D9_S197_L001_R1_001.fastq 7070 6525 ## Mock_S280_L001_R1_001.fastq 4779 4333 Wait for a while as your machine processing your request to trim and filter the amplicons. When it is done, the resulting amplicons will be located in the filtered_path you have stated earlier. You can track the number of in-and-out filtered reads for each sample in tnf_summary. 4.4 Infer Sequence Variants After filtering, typical workflow will continue to perform clustering of the DNA sequences into Operational Taxonomic Units (OTUs) or the estimated distinct species present in the community. This is performed by creating groups of sequencing reads that differ by less than a fixed dissimilarity threshhold. Even so, there is still a possibility of sequencing errors generating artificial sequences. To tackle this problem, a high-throughput DADA2 method was developed. This method can infer amplicon sequence variants (ASVs) from our amplicons data. ASVs are individual DNA sequences recovered after the removal of false sequences generated from error during PCR amplification and sequencing. ASVs are considered as the true biological sequences and therefore will be used for further analysis. DADA2 works by making use of a parametric error model err to distinguish between true biological sequences (ASVs) and those generated by error Ben J. Callahan (2016). This error model learns the maximum possible error rates of our amplicons data using the learnErrors() function (Callahan, n.d.). The error model will later be used in the DADA2 algorithm using dada() function. # error model for forward reads error_F &lt;- learnErrors(filtered_F) #input: file path for filtered reads # error model for reverse reads error_R &lt;- learnErrors(filtered_R) # infer sequence variants dada_F &lt;- dada(filtered_F, err = error_F, verbose = FALSE) dada_R &lt;- dada(filtered_R, err = error_R, verbose = FALSE) Let’s check dada2 result from the first sample forward reads. Dada infer 130 true amplicon sequence variants from 1866 unique sequences. dada_F[1] ## $F3D0_F_filtered.fastq.gz ## dada-class: object describing DADA2 denoising results ## 130 sequence variants were inferred from 1866 input unique sequences. ## Key parameters: OMEGA_A = 1e-40, OMEGA_C = 1e-40, BAND_SIZE = 16 4.5 Merge Forward &amp; Reverse Reads The DADA2 algorithm removed (nearly) all substitution errors from the data and the data are now ready to be merged. merged &lt;- mergePairs(dadaF = dada_F, # dada result derepF = filtered_F, # path of filtered reads dadaR = dada_R, derepR = filtered_R) 4.6 Construct Sequence Table &amp; Remove Chimeras Using the merged pairs of the amplicon data, a sequence table or in this case an amplicon sequence variant (ASV) table can be generated. This table is in matrix format with rows stores the sample names and the columns stores the number of each ASVs. From this table we can inspect the number of ASVs (representing each microbial species) in each sample. ASV table is a higher-resolution version of the OTU table produced by tradisional method. We can construct a sequence table using makeSequenceTable(). seqtab &lt;- makeSequenceTable(merged) Below is a glimpse of what our seqtab matrix looks like: # first 3 observation; first 3 ASV (named by its DNA sequence) seqtab[1:3,1:3] ## GCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGCAGGCGGAAGATCAAGTCAGCGGTAAAATTGAGAGGCTCAACCTCTTCGAGCCGTTGAAACTGGTTTTCTTGAGTGAGCGAGAAGTATGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACTCCGATTGCGAAGGCAGCATACCGGCGCTCAACTGACGCTCATGCACGAAAGTGTGGGT ## F3D0 582 ## F3D1 417 ## F3D141 442 ## GCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGCAGGCGGACTCTCAAGTCAGCGGTCAAATCGCGGGGCTCAACCCCGTTCCGCCGTTGAAACTGGGAGCCTTGAGTGCGCGAGAAGTAGGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACTCCGATTGCGAAGGCAGCCTACCGGCGCGCAACTGACGCTCATGCACGAAAGCGTGGGT ## F3D0 345 ## F3D1 354 ## F3D141 363 ## GCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGTAGGCGGGCTGTTAAGTCAGCGGTCAAATGTCGGGGCTCAACCCCGGCCTGCCGTTGAAACTGGCGGCCTCGAGTGGGCGAGAAGTATGCGGAATGCGTGGTGTAGCGGTGAAATGCATAGATATCACGCAGAACTCCGATTGCGAAGGCAGCATACCGGCGCCCGACTGACGCTGAGGCACGAAAGCGTGGGT ## F3D0 451 ## F3D1 232 ## F3D141 347 We have three ASVs (sequences) and its number on each of our first three samples. For more tidy visualization, we can change the simplify the sample names: rownames(seqtab) &lt;- sample_names dim(seqtab) ## [1] 20 286 We have a total of maximum 286 ASVs or expected microbial species that may present in a community sample. The last data cleaning step that we can do is to remove chimeras. Chimeras are DNA sequences which are formed from 2 or more biological sequences joined together (Fig 4.2). These chimeras can act as distinct microbial species alone when in fact it is not a true microbial sequences. Chimeras can be identified if they can be exactly reconstructed by combining a left-segment and a right-segment from two more abundant “parent” or biological sequences. We can remove chimeras using function removeBimeraDenovo(). seqtab_nochim &lt;- removeBimeraDenovo(seqtab, method = &quot;consensus&quot;) dim(seqtab_nochim) ## [1] 20 234 Removing chimeras leave us with 234 ASVs from the original 286 ASVs we previously have. Even so, if you calculate the percentage of chimeric sequences from the total abundance of all sequences, it only accounts for 4% of the data. This amount is small and acceptable. On the other hand, if your analysis indicates a lot of chimeric sequences there might be some upstream processes that have gone wrong such as not removing the primer sequences from the fasta prior to reading the data Callahan (n.d.). You can track the number of reads or sequences that made it through each step of the processes. # create function to get the sum of unique DNA getN &lt;- function(x) { sum(getUniques(x)) } # generate the summary track_reads &lt;- data.frame(row.names = sample_names, raw_reads = tnf_summary[,1], filtered = tnf_summary[,2], ASVs_F = sapply(dada_F, getN), # sapply to apply the function to all rows (sample) ASVs_R = sapply(dada_F, getN), joined = sapply(merged, getN), no_chimera = rowSums(seqtab_nochim)) # form row-column sums track_reads ## raw_reads filtered ASVs_F ASVs_R joined no_chimera ## F3D0 7793 7139 7021 7021 6667 6655 ## F3D1 5869 5314 5252 5252 5028 5028 ## F3D141 5958 5478 5369 5369 4995 4867 ## F3D142 3183 2926 2822 2822 2611 2546 ## F3D143 3178 2955 2837 2837 2598 2564 ## F3D144 4827 4323 4175 4175 3690 3540 ## F3D145 7377 6762 6622 6622 6150 5873 ## F3D146 5021 4580 4456 4456 4003 3901 ## F3D147 17070 15695 15505 15505 14080 12980 ## F3D148 12405 11448 11283 11283 10567 10027 ## F3D149 13083 12064 11917 11917 11166 10705 ## F3D150 5509 5054 4897 4897 4392 4306 ## F3D2 19620 18130 17977 17977 17520 16952 ## F3D3 6758 6275 6179 6179 5911 5611 ## F3D5 4448 4068 3932 3932 3723 3723 ## F3D6 7989 7394 7268 7268 6904 6716 ## F3D7 5129 4772 4657 4657 4435 4222 ## F3D8 5294 4890 4806 4806 4583 4553 ## F3D9 7070 6525 6397 6397 6154 6075 ## Mock 4779 4333 4309 4309 4292 4292 From the summary, we know that there is no over-large drop associated with any single step and we manage to keep majority of our data. Now we can move to the next step. 4.7 Assign Taxonomy Previous amplicon bioinformatics processes provide us with a sequence table containing the number of distinct amplicons (ASVs) which resembles a microbial species in each of our sample. This table will be more informative and easier to analyze when we have assign the taxonomy or identity for each ASVs in the table. That is like giving an identity to the considerably long ACGT-code in the into something more “readable” for the column names. Assigning taxonomy is a process of classifiying an unknown ASVs into a known microbial species. Using DADA2 package, it involves a native implementation of the naive Bayesian classifier method. The function assignTaxonomy() will take an input of a set of sequences to be classified (ASVs) a nd a training set of reference sequences with known taxonomy. The function will output taxonomic assinments for all ASVs with at least minBoot bootstrap confidence (parameter for the algorithm). Do it looks like a machine learning classification case? Yes, it is. There are various resources for training set fastas, but I will use the Silva reference database (McLaren 2020) for this example. To use it, go to this link and download these files: silva_nr_v138_train_set.fa.gz silva_species_assignment_v138.fa.gz and then place the files inside the same directory with our filtered sequences .fastq.gz files. We can then perform taxonomy assignment: # assign taxa until genus level taxa &lt;- assignTaxonomy(seqtab_nochim, # sequence table refFasta = &quot;data/filtered/silva_nr_v138_train_set.fa.gz&quot;, # reference sequence minBoot = 50) # minimal bootstrap confidence; default to 50 # add taxa until species level # note that it may result NA if there is no exact match in the reference taxa &lt;- addSpecies(taxa, # result from assignTaxonomy refFasta = &quot;data/filtered/silva_species_assignment_v138.fa.gz&quot;) # check taxonomic assignment taxa_print &lt;- taxa rownames(taxa_print) &lt;- NULL # for visualization purpose head(taxa_print) ## Kingdom Phylum Class Order Family ## [1,] &quot;Bacteria&quot; &quot;Bacteroidota&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot; &quot;Muribaculaceae&quot; ## [2,] &quot;Bacteria&quot; &quot;Bacteroidota&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot; &quot;Muribaculaceae&quot; ## [3,] &quot;Bacteria&quot; &quot;Bacteroidota&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot; &quot;Muribaculaceae&quot; ## [4,] &quot;Bacteria&quot; &quot;Bacteroidota&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot; &quot;Muribaculaceae&quot; ## [5,] &quot;Bacteria&quot; &quot;Bacteroidota&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot; &quot;Bacteroidaceae&quot; ## [6,] &quot;Bacteria&quot; &quot;Bacteroidota&quot; &quot;Bacteroidia&quot; &quot;Bacteroidales&quot; &quot;Muribaculaceae&quot; ## Genus Species ## [1,] NA NA ## [2,] NA NA ## [3,] NA NA ## [4,] NA NA ## [5,] &quot;Bacteroides&quot; NA ## [6,] NA NA For those of you who were more exposed to the manual approach of assigning taxonomy (using clustering)–like me in my university years, you must be quite confused with this new classification approach. In the manual approach, for each unknown species, we perform clustering of unknown DNA with the reference database and perform taxonomy assignment based on the highest DNA sequence similarity. DADA2 approach is rather different. But using this new algorithm to perform massive taxonomy assignments on numerous unknown species simultaneously is considered a common approach now. Personally, I captured this as a solid movement towards the rising of Big Data era in Biology, just like the data we use in this book. In this point, youu can additionally check the accuracy of DADA2 algorithm in inferring sequence variants by comparing the result of mock samples to the annotated sequence of mock samples HMP_mock.v35 fasta. I’ll leave it for you to explore the original documentation here. 4.8 Create Phyloseq Object After many process of amplicon bioinformatics, the last thing we can do is to combine all the processed data into a phyloseq object. A phyloseq object will be in a .csv format which will be easier for us to manipulate for microbiome analysis. We can create a phylosec object by combining several metadata and the result of our DADA2 process. We will use the sample names which stores the information. Keep in mind that we have to pay attention to where is the mock sample is located for it has different naming system and therefore needs special treatments. sample_names ## [1] &quot;F3D0&quot; &quot;F3D1&quot; &quot;F3D141&quot; &quot;F3D142&quot; &quot;F3D143&quot; &quot;F3D144&quot; &quot;F3D145&quot; &quot;F3D146&quot; ## [9] &quot;F3D147&quot; &quot;F3D148&quot; &quot;F3D149&quot; &quot;F3D150&quot; &quot;F3D2&quot; &quot;F3D3&quot; &quot;F3D5&quot; &quot;F3D6&quot; ## [17] &quot;F3D7&quot; &quot;F3D8&quot; &quot;F3D9&quot; &quot;Mock&quot; Below we will extract the information one by one: gender &lt;- substr(sample_names, start = 1, stop = 1) # get the first character gender ## [1] &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; ## [20] &quot;M&quot; subject &lt;- substr(sample_names, 2, 2) # get the second character subject ## [1] &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; &quot;3&quot; ## [20] &quot;o&quot; day &lt;- sapply(strsplit(sample_names, &quot;D&quot;), `[`, 2) %&gt;% # separate by &#39;D&#39;; get the 2nd value [2] as.integer() # convert to integer day ## [1] 0 1 141 142 143 144 145 146 147 148 149 150 2 3 5 6 7 8 9 ## [20] NA # combine metadata seq_data &lt;- data.frame(Subject = subject, Gender = gender, Day = day, When = ifelse(day &lt; 100, &quot;Early&quot;, &quot;Late&quot;), # add early/late sampling period row.names = sample_names) head(seq_data) ## Subject Gender Day When ## F3D0 3 F 0 Early ## F3D1 3 F 1 Early ## F3D141 3 F 141 Late ## F3D142 3 F 142 Late ## F3D143 3 F 143 Late ## F3D144 3 F 144 Late Now let’s create a phylosec object: # create phylosec object ps &lt;- phyloseq(otu_table(seqtab_nochim, taxa_are_rows=FALSE), sample_data(seq_data), tax_table(taxa)) # remove mock sample ps &lt;- prune_samples(sample_names(ps) != &quot;Mock&quot;, ps) ps ## phyloseq-class experiment-level object ## otu_table() OTU Table: [ 234 taxa and 19 samples ] ## sample_data() Sample Data: [ 19 samples by 4 sample variables ] ## tax_table() Taxonomy Table: [ 234 taxa by 7 taxonomic ranks ] ## refseq() DNAStringSet: [ 234 reference sequences ] It is also better to merge the sequences of our ASVs in the phyloseq object. We will use function from Biostrings package to extract sequences from ASV table. The sequences are stored as taxa names in ASVs table (labelled as OTU table). # get sequences dna &lt;- Biostrings::DNAStringSet(taxa_names(ps)) names(dna) &lt;- taxa_names(ps) # connect dna data to taxa names dna ## A DNAStringSet instance of length 234 ## width seq names ## [1] 232 GCGAGCGTTATCCGGATTTATT...GCTCATGCACGAAAGTGTGGGT GCGAGCGTTATCCGGAT... ## [2] 232 GCGAGCGTTATCCGGATTTATT...GCTCATGCACGAAAGCGTGGGT GCGAGCGTTATCCGGAT... ## [3] 232 GCGAGCGTTATCCGGATTTATT...GCTGAGGCACGAAAGCGTGGGT GCGAGCGTTATCCGGAT... ## [4] 232 GCGAGCGTTATCCGGATTTATT...GCTGAGGCACGAAAGTGCGGGG GCGAGCGTTATCCGGAT... ## [5] 233 CCGAGCGTTATCCGGATTTATT...ACTGATGCTCGAAAGTGTGGGT CCGAGCGTTATCCGGAT... ## ... ... ... ## [230] 233 GCAAGCGTTATCCGGAATGACT...ACTGAGGCACGAAAGCGTGGGG GCAAGCGTTATCCGGAA... ## [231] 233 GCGAGCGTTATCCGGATTTATT...GTTGAGGCACGAAAGTGTGGGG GCGAGCGTTATCCGGAT... ## [232] 232 GCGAGCGTTATCCGGATTCATT...GCTGAGGCGCGAAAGCTGGGGG GCGAGCGTTATCCGGAT... ## [233] 232 GCGAGCGTTATCCGGATTCATT...GCTGAGGCGCGAAAGCTAGGGG GCGAGCGTTATCCGGAT... ## [234] 232 GCGAGCGTTATCCGGATTTATT...GCTGAGGCACGAAAGCGTGGGG GCGAGCGTTATCCGGAT... # merge data ps &lt;- merge_phyloseq(ps, dna) # change taxa names into shorter id (ASVn) taxa_names(ps) &lt;- paste0(&quot;ASV&quot;, seq(ntaxa(ps))) Now, we can easily retrieve DNA sequences for each ASVs using taxa names as key id. # first three ASVs in our samples otu_table(ps)[,1:3] ## OTU Table: [3 taxa and 19 samples] ## taxa are columns ## ASV1 ASV2 ASV3 ## F3D0 582 345 451 ## F3D1 417 354 232 ## F3D141 442 363 347 ## F3D142 290 305 159 ## F3D143 231 176 204 ## F3D144 424 277 304 ## F3D145 647 494 523 ## F3D146 326 231 254 ## F3D147 1499 1220 913 ## F3D148 870 732 580 ## F3D149 887 781 725 ## F3D150 318 232 402 ## F3D2 3509 1594 1179 ## F3D3 998 606 469 ## F3D5 322 265 284 ## F3D6 1017 675 590 ## F3D7 649 504 439 ## F3D8 277 356 352 ## F3D9 512 426 485 # first 3 ASVs sequences refseq(ps)[1:3] ## A DNAStringSet instance of length 3 ## width seq names ## [1] 232 GCGAGCGTTATCCGGATTTATTG...CGCTCATGCACGAAAGTGTGGGT ASV1 ## [2] 232 GCGAGCGTTATCCGGATTTATTG...CGCTCATGCACGAAAGCGTGGGT ASV2 ## [3] 232 GCGAGCGTTATCCGGATTTATTG...CGCTGAGGCACGAAAGCGTGGGT ASV3 We finally have our final phyloseq object containing ASVs table, our sample metadata, taxonomy table for our ASVs, and its DNA sequences. ps ## phyloseq-class experiment-level object ## otu_table() OTU Table: [ 234 taxa and 19 samples ] ## sample_data() Sample Data: [ 19 samples by 4 sample variables ] ## tax_table() Taxonomy Table: [ 234 taxa by 7 taxonomic ranks ] ## refseq() DNAStringSet: [ 234 reference sequences ] After creating the phylosec object, we are ready to dive deeper into microbiome analysis in the next chapter! "]
]
